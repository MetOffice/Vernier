name: Deploy all tests

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths-ignore:
      - '.github/workflows/documentation.yml'
      - '.github/workflows/coverage.yml'
  pull_request:
    branches: [ main ]
    paths-ignore:
      - '.github/workflows/documentation.yml'
      - '.github/workflows/coverage.yml'

env:
  COMPILER_MATRIX: >
    [ {c: gcc-10,   cpp: g++-10,     fortran: gfortran-10 }, 
      {c: clang-12, cpp: clang++-12, fortran: gfortran-10 } ]

jobs:

  build-install:
    # The reusable build workflow is called for each compiler configuration
    # and for both static and dynamic linking.
    name: "Build/install: ${{ matrix.compiler.cpp }}"
    strategy:
      matrix: 
        compiler: ${{ env.COMPILER_MATRIX }}
        shared_libs: [ true, false ]
    uses: ./.github/workflows/build.yml
    with:
      c_compiler:       ${{ matrix.compiler.c }}
      cpp_compiler:     ${{ matrix.compiler.cpp }}
      fortran_compiler: ${{ matrix.compiler.fortran }}
      shared_libs:      ${{ matrix.shared_libs }}

  unit_test:
    # Unit tests ran for the same compiler configurations as before, but only
    # the dynamic build is tested.
    name: "Unit test: ${{ matrix.compiler.cpp }}"
    needs: [ build-install ]
    strategy:
      matrix:
        compiler: ${{ env.COMPILER_MATRIX }}
    uses: ./.github/workflows/unit.yml
    with:
      cpp_compiler: ${{ matrix.compiler.cpp }}

  system_test:
    # System test is compiled and ran for all compiler configurations, using
    # both the static and dynamic artifacts.
    name: "System test: ${{ matrix.compiler.cpp }}"
    needs: [ build-install ]
    strategy:
      matrix: 
        compiler: ${{ env.COMPILER_MATRIX }}
        shared_libs: [ true, false ]
    uses: ./.github/workflows/system.yml
    with:
      cpp_compiler: ${{ matrix.compiler.cpp }}
      fortran_compiler: ${{ matrix.compiler.fortran }}
      shared_libs: ${{ matrix.shared_libs}}